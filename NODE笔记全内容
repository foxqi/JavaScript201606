第一类  （客户端和服务器端模型）

1.电脑扫盲
  window+r-->cmd-出现-->
黑框叫做--DOS命令窗口-->一些常用命令
     1）ipconfig--查看自己的电脑的IP地址
        ipconfig -all---查看自己的电脑的IP地址（更加详细）
     2）看网速快不快----ping www.baidu.com -t(时间越少网速越快，可以（ping任何一个网站）)  -->ctrl+c（终止正在运行的DOS
     命令）
     3）exit-->关闭DOS命令窗口（直接点红x关闭也可以，那是更逼格的）
     4）cls（清屏）

     5）文件夹的东西
       返回当前文件夹的上一级目录cd ../
       当前目录cd ./
       返回当前磁盘的根目录cd /
       直接进入到D盘 D：
       直接进入到某盘  某盘:
       cd 文件夹名  进入到指定的文件夹中
       dir 查看当前文件夹下的目录

       以上所有的操作基本上都是为了进入某一个文件夹下操作，但是我们不必这么纠结，我们直接找到对应的文件夹，在文件夹的空白处shift+鼠标右键=>在此处打开命令窗口


     mkdir 你想创建的文件夹 -创建文件



2.扫盲继续
  1）自己做一个网站，想让别人看见，如何做？
      1.买个服务器（但是太贵了，可以买一台虚拟的服务器空间，或云服务器--》可以买阿里云服务器（比较稳定））
      2.服务器连接上网后，会存在一个外网IP地址，把我们开发的项目源文件（HTML/CSS/JS/IMG...）都上传到服务器上（用FTP上传都上传上服务器上）。
      3.买一个域名（可以去万网买域名）
      4.进行DNS解析（在万网里会告诉叫域名解析）：
        DNS是一个网络服务器，这个服务器属于全世界的。我们的域名解析其实就是在DNS上记录一条信息记录
        --www.zhouxiaotian.cn（域名）   220.114.23.56(服务器外网IP地址)   80（服务器端口号）

  2）当用户在自己的浏览器中输入一个网址，到最终看到页面和内容，发生了哪些事情？
    看图（在第七周_AJAX第一次接触）


->服务器的端口号：（有个范围在0~65535之间，一台服务器可以最多发布65535这么多项目）
  我们的一台服务器上可以发布很多的项目，而每一个项目都有一个自己对应的房间或者区域，服务器使用端口号来区分具体是哪一项目。

  一般我们都把自己的项目发布到80/443这俩个端口下

  引擎(解析出一个个样式)：每个浏览器都有自己不同的引擎，谷歌浏览器是V8引擎（webkit） 火狐浏览器是Gecko引擎  IE浏览器Trident引擎

  W3C：
  一个制定开发规范的非盈利性机构组织   HTML/HTML5/CSS/CSS3/Ecmascript...的规范都是由组织制定和管理的
  我们作为一名开发者开发页面，是按照规范来进行开发的
  浏览器开发商也一般按照W3C的规范开发浏览器的渲染引擎的。

  但是浏览器厂商总要凸显自己的与众不同，有些厂家把W3C实现完成后，又增加了一些自己的独有的好的东西（谷歌）。这样就导致了我们在写代码的时候经常写：-webkit-xxxx（这样写是谷歌独有的）。
  但是有些厂商，为了凸显自己的不一样，就不按照规范来，而是走自己的这一套（例如IE），这样就导致了我们编写的代码想要兼容所有的浏览器需要写多套：谷歌：getComputeredStyle  ，IE: currentStyle



->谷歌浏览器控制台NetWork这一项，可以看见当前的客户端向服务器端发送的所有的请求以及请求的状态信息等

->通过在NetWork中观看，发现当我第一次HTML源代码请求回来的时候，浏览器开始按照自己的引擎渲染，在渲染过程中我们还会出现重新向服务器请求CSS/JS/IMG...，每一次的请求步骤和HTML的步骤一摸一样。如果请求的资源次数过多，页面打开的速度和渲染的速度就会变慢，所有我们以后再页面优化的方法中，首先要做的就是减少资源请求数（减少HTTP请求）
   1）CSS合并成一个 或者 如果CSS不是很多的话 我们采用内嵌式CSS
   2）JS合成一个 或者 采用内嵌式
   3）图片合并（雪碧图技术/CSS Sprite） 或者 图片延迟加载
   4）图片延迟加载，不是为了减少流量，只是为了加快第一次加载页面的速度
   5）Ajax请求和资源文件的请求原理是一样的


->URI/URL/URN
  URI=URL+URN  统一资源标识符（统一资源信息）
   URL：统一资源定位符
       http://v.qq.com：80/index.html?name=zhufeng&age=7#bbs(完整的URL)
       http：传输协议  ->客户端给服务器的内容和服务器端传递给客户端的内容都是通过HTTP传输协议进行传输的（我们可以把HTTP理解为快递小哥）
       v.qq.com：域名
       80：端口号
       index.html:请求资源文件名   ->告诉服务器我需要请求的资源文件是谁
       ?name=zhufeng&age=7:URL问号传参  ->客户端传递给服务器端的内容（客户端可以把一些值传递给服务器端，服务器端依然可以把一些内容传递给客户端）
       #bbs：URL的hash（锚点定位又叫哈希值）
    URN：统一资源名称


->传输协议：
   HTTP：超文本传输协议,除了传输文本外，还可以传输其他东西，例如：XML等（一般小东西用来传输）。
   HTTPS：更加安全的HTTP；
   FTP：文件传输协议（引用于把项目源文件传递到服务器上）（大型拖运）

   在不指定服务器端口的情况下，每一种协议会有一个默认找的端口地址
   ->HTTP默认会找服务器的80端口
   ->HTTPS默认会找服务器的443端口
   ->FTP默认会找服务器的21端口

*****************************************************************************************************************
第二类  NODE基础知识（其他知识在AJAX第一天的js文件中）

JS
->JS是一门“运行在客户端（运行在浏览器）”的“轻量级”的脚本编程语言
->JS目前不仅仅只能在浏览器中运行，还可以在NODE中运行
node

1.什么是NODE？
   NODE是一个环境，供JS代码执行的环境，我们可以把它等价于浏览器，只不过我们一般都会把NODE这个环境安装到服务器端，这样的话我们就可以在服务器端使用JS编程程序了，也就是说JS不仅仅是客户端的语言也是服务器端的语言...

2.NODE &&浏览器的区别
   ->NODE采用的谷歌的v8引擎来渲染JS的（运行的速度快，稳定，我们编写的JS代码不需要考虑兼容）
   ->浏览器中的全局JS对象是window，而NODE环境下的全局JS对象是Global
   ->浏览器是安装在客户端的，为了保护客户端的安全，基本上不可能提供用JS对客户电脑磁盘上的文件进行操作的功能；但是NODE环境中提供了对应的I/O操作（服务器上文件的操作），我们使用JS可以对服务器磁盘下的文件，进行增删改查

  ->NODE提供给JS很多新的方法 :http:createServer、fs.writeFileSync、fs.readFileSync...
  ->NODE是基于事件驱动的/异步编程（我们在NODE环境下的编写的JS程序一般都是异步编程程序）

3.如何让JS代码在NODE中执行？
  ->利用webStorm嵌入了NODE的机制，直接把编写的JS通过右键“Run xxx.js”在NODE环境中执行（不建议经常这样使用，因为有些时候会有缓存）

  ->在命令窗口中执行
    在当前要执行的JS文件目录下，shift+右键=>在此处打开命令窗口=>node xxx.js 相当于把JS代码在NODE环境中执行了
    在NODE中执行JS代码和浏览器中执行一样，如果JS代码发生了修改，想要看到最新的效果需要重新的执行对应的JS文件（直接点向上键）
  ->在命令窗口中执行node，然后开始编写对应的JS代码测试即可（RPEL命令操作），和在浏览器的控制台写JS代码测试一样

4.NODE模块(提供了很多方法供JS在NODE使用)
  ->内置模块（NODE环境天生提供的）：http（createServer..）、fs（writeFileSync、readFileSync..）、url...


  ->自定义模块（我们自己定义的模块）：
    在NODE环境中，我们在当前的项目下创建一个JS文件，就相当于创建了一个模块，例如：新建一个a.js，相当于创建了a模块
    如果需要提供一些方法给其他的模块使用，则需要通过module.exports把方法导出，例如，在A模块中写了 module.exports={fn:fn}/module.exports.fn=fn
    如果现在B模块中使用，我们需要先导入 var a=require("./a")(./是指当前目录下，不写也可以)；这样的话我们就可以调取A模块中导出的方法了 a.fn();


  ->第三方模块（插件，别人写好的模块我们拿来使用）：在NODE中，我们如果需要使用别人的模块，需要使用npm这个命令进行管理  http：//www.npmjs.com/（一个第三方模块下载的地方）
    安装：npm install 第三方模块名称 -g （安装到NODE的全局环境中）
      安装成功后在JS中通过 var less=require("less");把刚才安装的第三方模块导入JS中，这样的话我们就可以使用这个模块中提供的方法了 less.render 写完后 ，在命令窗口执行你编写的js文件，就出现css样式
      卸载：npm uninstall 第三方模块名称 -g

5.服务创建成功后，如何的向服务器端发送请求？
  ->浏览器中输入  http://localhost:端口号/
  ->浏览器中输入  http://本机的IP地址:端口号/

6.//->导入我们三个常用的NODE内置模块
  var http = require("http"),
      fs = require("fs"),
      url = require("url");//->URL模块中提供了一个方法 url.parse() 用来解析URL地址的

  //1、HTTP模块
  //->http.createServer:创建一个服务,变量server就是我们创建出来的那个服务
  //->server.listen:为这个服务器监听一个端口80
  var server = http.createServer(function (request, response) {
      //->当客户端向服务器端的当前服务(端口号是80这个服务)发送一个请求,并且当前服务已经成功接收到这个请求后执行这个回调函数

      //->request(请求):存放的是所有客户端的请求信息，包含客户端通过问号传参的方式传递给服务器的数据内容
      //->request.url:存放的是客户端请求的文件资源的目录和名称以及传递给服务器的数据，例如：客户端请求的地址:http://192.168.0.32/index.html?name=zhufeng&age=7 我们服务端通过request.url获取到的是:/index.html?name=zhufeng&age=7

      var urlObj = url.parse(request.url, true),
          pathname = urlObj.pathname,
          query = urlObj.query;

      if (pathname === "/1.html") {
          //->根据请求的URL地址(具体的是根据地址中的pathname)获取到对应资源文件中的源代码
          //->fs.readFileSync([path+name],[encode]):同步读取指定文件中的内容(同步读取:文件中的内容读取不完不执行下面的操作,只有都读取出来才会执行后续的操作)
          var con = fs.readFileSync("./1.html", "utf-8");

          //->response(响应):提供了向客户端返回内容和数据的方法
          //->response.write:向客户端返回内容
          //->response.end:告诉服务器响应结束了(一定要加)
          response.write(con);
          response.end();
      }
  });

  server.listen(80, function () {
      //->当服务创建成功，并且端口号也监听成功之后执行这个回调函数
      console.log("server is create success,listening on 80 port!");
  });