
第一大类：关于github

命令行常用命令：
 mkdir test(文件夹名字)：创建一个新的文件夹
 ls 查看目录
 cd test :进入这个文件夹
 pwd ： 查看路径

一、git 工作流程
1.git工作流总结
    1.创建一个空目录 mkdir
    2.进入目录： cd 目录名
    3.git init 初始化仓库
    4.新建文件到工作区
    5.git add 添加到暂存区
    6.git commit -m"注释" 添加到历史区
2.本地仓库和远程仓库关联起来
    git remote add origin 远程仓库的地址
    git remote add origin https://github.com/zhufengpeixun/JavaScript201606.git
    查看远程仓库地址：
    git remote -v
    解除关联
    git remote rm origin
3.远程仓库内容更新到本地仓库
    git pull origin master
4.把本地内容提交到远程仓库
    git push origin master
二、常用git命令总结
    1.git pull origin master (这个一般是多人开发)
    2.给本地仓库添加新内容
    3.git add 要添加的文件名
    4.git commit -m"新文件注释"
    5.git push origin master
三、git作业流程
    1.fork 讲师仓库的地址https://github.com/zhufengpeixun/JavaScript201606
    2.克隆你自己的项目地址 git clone 仓库地址
    https://github.com/你的github用户名/JavaScript201606.git
    3.修改工作区的本地代码，添加你的练习
    4.git add .或者 -A 提交到暂存区
    5.git commit -m"提交练习" 提交到历史区
    6.git push origin master 推送到本人的github上
    7.远程github上，点击new pull request按钮
    8.点击 create pull request
        这里可以添加标题和内容
    9.由讲师来合并代码
四、学员更新老师讲义
    1.fork珠峰培训讲师的仓库：
        1）登录自己的github
        2）把讲师仓库地址复制到地址栏
        3）fork
    2.把自己的仓库下载到本地
        1）git clone 自己的地址
        2）git remote -v 查看当前本地都和哪些远程仓库保持了链接 (删除本地与远程仓库的通道：git remote rm origin名字)
    3.在本地增加和讲师仓库链接
        1）git remote add zhufeng(名字) 讲师的仓库地址
        2）git remote -v 查看当前本地都和哪些远程仓库保持了链接 (删除本地与讲师仓库的通道：git remote rm zhufeng )
    4.拉取老师的最新讲义信息
        1）git remote update zhufeng (把本地和珠峰培训的链接通道进行更新)
        2）git pull zhufeng master(把最新的讲义代码拉取到本地)
    5.把本地拉取的最新讲义更新到自己的仓库中
        1)git add ./-A
        2)git commit -m”注释”
        建议：git pull origin master(每次推送之前，先进行拉取；防止仓库中最新的本地没有，适用于多人开发)
        3)git push origin master 把本地代码推送到自己的远程仓库中
    注意：前3步第一次操作完成，以后都不需要再操作，以后操作直接从第四步开始；

    1.git的一些常用命令
        mkdir 创建一个新的文件夹
        cd 文件夹 --进入一个文件夹
        ls - 显示文件夹下的内容（可视内容）
        ls -al 显示文件夹下所有的内容（可视的内容和隐藏的内容）
    2.git 工作流的操作
        1.在本地新建一个文件夹
        2.进入到这个夹 左手shift+右键 -》进入命令行
        也可以直接右键 git Bash here
        3.mkdir 测试文件夹 leilei
        也可以手动创建一个文件夹
        4.进入测试文件夹 -- cd leilei(文件夹名字)
        5.把本地仓库初始化为一个git的本地仓库 -- git init
        因为：只有把本地仓库初始化为git仓库后，才可以用git来操控；
        6.给本地文件夹添加新内容
        7.git add . 这是把所有的文件都保存到暂存区
            git add -A 这是把所有的文件都保存到暂存区
            git add aa.txt 把指定的文件添加到暂存区
        8.git commit -m"注释的内容" 这是把暂存去的内容添加到历史区
        9.添加一个远程自己的仓库 git remote add origin 地址；
            备注：如何查看自己本地连接了哪些远程仓库？
            git remote -v
        10.把本地文件推送到远程仓库 git push origin master
        把本地仓库的内容推送到远程origin地址的master分支上去；
    3.更新老师讲义的步骤
        1.登录你们自己的github；然后把老师讲义的地址，复制到你们github的地址栏
        https://github.com/zhufengpeixun/JavaScript201606
        2.点击老师讲义右侧的fork；（克隆一份一模一样的代码到自己的远程仓库）
        3.把自己的远程仓库克隆到自己的本地仓库；
        git clone https://github.com/你们自己的github用户名/JavaScript201606-1.git
        4.当老师讲义有更新的时候；
        1）建立与老师远程仓库的连接通道
        git remote add teacher https://github.com/zhufengpeixun/JavaScript201606
        2)更新与老师远程仓库的连接通道
        git remote update teacher
        3)把更新的内容拉到本地
        git pull teacher master
        4）把本地更新的内容，推送到自己的远程仓库上去 origin
        git add ./-A 添加到暂存区
        git commit -m"注释" 添加到历史区
        git push origin master
        5)可以给老师学生作业文件夹下添加本组的作业
        git add ./-A 添加到暂存区
        git commit -m"注释" 添加到历史区
        git push origin master
        6）点击 new pull request
           点击 create pull request
           标题栏：谁谁的作业
           内容：老师，我发现一种更简单的方式；
            create pull request
       忠告：down下来别人的作业后，不要随便修改；否则会引起冲突；

***************************************************************************
 第二大类   预解释
  10.为何学习预解释：
      1.如果函数中未定义此变量，为何还能拿到
      2.函数中定义的变量，但是在赋值之前，我们仍然能拿到值，但是拿到是undefined
      3.为何把var去掉程序还能正常执行；
      4.在定义函数之前，调用函数，也能执行函数，为什么？
  最终目的：写代码时，思路更加清楚，知道为何程序能正常执行，为何会报错？避免很多不正规的写法，因为这些不正规的写法很容出错，而且不会报错；
  11.预解释：
     概念：在当前作用域下，在JS代码执行之前，浏览器会对带var和带function进行提前声明或者定义；
     声明：告诉浏览器有这么一个变量，但是没有赋值，没赋值拿到的undefined;
     定义：对已经声明过的这个变量进行赋值
     关于变量和函数预解释阶段的不同
     带var :只声明不定义
     带function:声明+定义；
     在预解释阶段，函数的优先级大于变量；
  12.函数包含：定义+调用
      定义3步骤：
          1.开辟一个空间地址
          2.把函数体中所有JS代码做为字符串存在这个空间中
          3.把空间地址赋值给函数名
      函数调用3步骤：
          1.对形参赋值；
          2.预解释 var n;
          3.JS代码从上到下的执行
  13.作用域链：当函数执行的时候，形成一个私有作用域A,查看作用域中的这个变量是否为私有变量：
      1）如果是私有变量：这个函数中的所有此变量，跟外面没有任何关系；
      2）如果不是私有变量：
          1.如果是获取；往上级作用域进行查找，如果找到，弹出，找不到继续往上级作用域进行查找。。。。最终一直找到window，如果还没有，报错
          2.如果是设置；往上级作用域进行查找，如果找到，重新赋值；找不到继续往上级作用域进行查找。。。。最终一直找到window，如果还没有，他就是window上的全局属性；
  14.关于作用域
      1）全局作用域：当浏览器加载html页面的时候，会形成一个供JS代码执行的环境；在这个全局作用域下，所有的全局变量都是window上的全局属性； 所有的全局函数，都是window上的全局方法；
      2）私有作用域
     window.setInterval(fn,1000)
     3）上级作用域：只跟当前函数对应的堆内存在哪里开辟有关，跟函数在哪里调用没有任何关系
  15.带var和不带var的区别
  带var:1）会进行预解释 2）如果是全局变量，window的全局属性
  不带var: 1)不会进行预解释 2）如果是设置；往上级作用域进行查找，如果找到，重新赋值；找不到继续往上级作用域进行查找。。。。最终一直找到window，如果还没有，他就是window上的全局属性；
  16.私有变量有且只有两种
      1.函数中带var的
      2.形参；
  (*(17)).关于预解释的无节操：
      1.自执行函数不需要预解释，当代码执行到他的时候；声明+定义+调用同步完成；
      2.已经声明过的变量，不需要重新声明，只需要重新赋值；
      3.对于带var的，我们只对等号左边，进行声明；不运行等号右边的（即只声明，不定义）
      4.if条件语句，无论条件是否成立，都会进行预解释
      注意：在if条件语句中不要定义函数；因为各大浏览器对if语句的预解释不同；很容易出错；
      5.return返回值不进行预解释；return下面的语句虽然不执行，但是会进行预解释(只声明，不定义)；
  18.闭包的作用
      1.防止变量名冲突
      2.在闭包中对全局变量重新赋值，并且不影响全局变量
      3.可以通过window.xx改变全局变量；
      4.闭包可以用来封装；可以通过window.xxx=函数名；
  19.函数当作表达式赋值给变量时注意事项：
     当函数做为表达式赋值给一个变量的时候，是按照变量的预解释机制进行预解释的；
     这个变量名，就相当于函数名，虽然不能在上面调用，但是可以在函数赋值后调用；

  20.内存：
  js中内存：堆内存 和 栈内存
  栈内存：提供了一个供JS代码执行的环境
  环境：全局环境，私有环境
  堆内存：存放是引用数据类型的值；对象：存的对象的属性名和属性值； 函数：把函数体中的JS代码做为字符串存在这个空间中
  21.内存释放：
     1） 堆内存释放：只要堆内存被变量占用，就无法释放； var a=xxff00; a=null;
         解决措施：让 变量名=null； 即，让变量名等于空指针，当浏览器空闲的时候，就会把指向空指针的变量收回，浏览器的这种回收机制，叫做垃圾回收机制；
     2）栈内存：
        1.全局作用域：当浏览器加载完HTML页面的时候，就形成一个全局作用域；只有关闭页面，才能释放；
          如果不关闭页面，那么全局作用域下的所有变量和内容都无法得到释放；
              我们唯一能做的就是减少全局变量；
        2.私有作用域：当函数执行的时候，形成一个私有作用域；一般情况下，当函数执行完成的时候私有作用域就被释放；
          有两种情况不会被释放：
              1.如果私有函数中有东西被函数外面的变量或者其他元素占用的时候，此函数不能释放；
              2.不立即释放；
              这个函数执行完成的时候，会返回一个函数，被返回的这个函数还需要再执行一次，等返回的函数执行完成，所有的函数才               能释放；
  22.++n 和 n++ 的区别：n=0;/1/2
  ++n 先++；再运算; 15+（++n）=16;15+（++n）=17;
  n++ 先运算，再++; 15+n++=15; 15+n++=16;
  注意：再++时，只是n自身的++；跟整个运算没有关系；
  23.什么时候用this：
  凡是公用方法中的this，如果有对象调用这个方法，且方法中需要用到调用这个方法的对象的时候，那么方法中就需要使用this来代替这个对象，这样才可以保证可以使用这个方法的对象都可以调用这个方法
   eg.因为你不知道是谁去调用，这次是ary 下次也许就不ary了
  24.关于this的小总结：
      1.当触发一个元素身上的事件，执行对应的函数的时候，函数中的this，指向当前这个元素；
      2.当函数执行的时候，"."前面是谁，this就是谁
      3.自执行函数中的this，永远都是window；
      4.在构造函数中，this指向当前实例
      5.回调函数中this指向window
      6.call()，apply(),bind()
*************************************************
第二大类   面向对象（设计模式：单例模式，工厂模式，构造函数模式，原型模式；）
10.对象由两部分构成：属性 和 方法；
11.面向对象的特点：
    1.封装：对于相同功能的代码，放在一个函数中，以后再用到此功能，只需要调用即可，无需再重写；避免大量冗余代码；
    专业话说：低耦合，高内聚；
    2.继承：子类继承父类原有的属性和方法；
    类：'Object','Function','Number','String','Array','RegExp','Date'.....
    3.多态：重载和重写；
    重载：在JS中不存在严格意义上的重载；但是，JS中有类似重载的功能:同一个函数，传不同的参数，实现不同的功能；
    重写：子类可以重写父类的属性和方法；
12.会学到的设计模式：单例模式，工厂模式，构造函数模式，原型模式；
13.单例模式：把描述同一事物的属性和方法，放在同一个命名空间下，避免了变量名冲突的问题；
命名空间：浏览器开辟了一个堆内存，给他分配的名字person1就是命名空间
单例模式本质：普通对象；
14.模块化开发：对于一个大型项目，项目组会分配给不同的工程师去开发（这些开发是同步进行的）；等所有人开发完成，合在一起，整个项目就完成了；
1)单例就是简单的模块化开发；
2)可以实现本模块间的相互调用：this.属性名;
3)可以实现模块之间的相互调用：模块名.属性名；
15.单例模式的优缺点：
优点：1）可以实现模块化开发 2）避免了属性名相同，以及变量名相同的冲突问题；
缺点：传统的手工作业模式，开发效率低，并且造成大量冗余代码；
解决措施：封装--工厂模式
16.工厂模式的思想：
    1.引进一批原材料----1.var obj={}; var obj=new Object();我们自己创建一个空对象
    2.对原材料进行加工---2.给空对象添加一些私有的属性和方法；
    3.输出原材料---3.输出对象 return obj;
工厂模式的本质：封装；
17.工厂模式在调用的时候，跟创建一个实例的区别：
    1）创建一个实例的时候：函数名首字母大写
    2）创建一个实例的时候： 有new ;
18.构造函数模式：--为了自定义一个类，并且可以创建一些实例；
实例 instanceOf 类；==》返回的是 boolean值；
构函数模式跟工厂模式的区别：
    1.在调用时候
    构造函数 new Person()；
    工厂模式 person();
    2.在函数体内的区别；
    构造函数：系统自动创建一个对象，给对象添加属性和方法，系统自动输出该对象；
    工厂模式：手动创建对象，给对象添加属性和方法，手动输出对象；
 缺点：对于相同的功能，却不相等；
 解决措施：prototype原型，把功能相同的代码，放在一个公共区间；
 19.为什么要使用构造函数模式：
          以前接触的系统提供的类：'Array' 'Date' 'Object' 'String' 'Number'....
          var ary=new Array();
          目的：为了实现一个自定义的类；并且可以创建一个实例；
          function Person(){}
          var p1=new Person;
 20.关于构造函数：
    1.构造函数中放的都是私有的属性和方法；
    2.就是实例和类在打交道；
    3.在创建一个实例的时候，如果不需要传参，小括号可以省略；
    4.构造函数this，永远指向当前实例；
    5.在构造函数中，实例只跟this.xxx有关系，跟变量没有任何关系；
    6.构造函数中，系统默认会为我们返回一个对象；如果我们手动返回的话：
    1）return 基本数据类型，不会造成任何影响；实例还有他的属性和方法；
    2）return 引用数据类型，会影响系统返回的对象，实例就没有他以前的属性和方法了；
   所以，一定不建议手动返回，除非，你已经掌握原理了；
((*21)).原型模式的基础知识：重中之重
    1）每一个函数数据类型（类，普通函数）上都天生自带一个属性，叫做prototype（原型），它是一个对象；
    2）prototype这个原型上，天生自带一个属性，叫做constructor,指向当前所属的类；
    constructor：类就是构造函数；
    3）每个对象(实例，普通对象，prototype)上，都天生自带一个属性，叫做__proto__,他指向当前实例所属的类的原型；
    注意：自己创建的对象上没有constructor这个属性

22.Object.prototype:都放的公有的属性和方法
hasOwnProperty:判断attr这属性是否是这个对象上的私有属性；
isPrototypeOf：obj1是否在obj2的原型链上；
propertyIsEnumerable：是否可枚举的属性；
23.
每个类都是函数数据类型；
Object是对象数据类型的基类；
24.
构造函数模式：实例 和 类；
原型模式：实例 ， 类， 原型；
构造函数里：私有的属性和方法；
prototype上：公有的属性和方法；
25.原型链    ：查找机制：比如要查找f1.x==>对象.属性名
1）在自己的私有属性上查找，如果找到那么这个属性就是私有属性；
2）如果没找到，通过__proto__去所属类的原型上进行查找，因为原型上放的都是公有的属性和方法，所以，如果找到，这个属性就是公有的；
3）如果还没找到，通过__proto__一层层往找，最终找到基类Object.prototye上，如果还没有，undefined！
((*26)).几个反应：重中之重；
    1.一看到函数名首字母大写：构造函数--》构造函数中放的都是私有的属性和方法；
    2.一看A.prototype：原型--》原型上放的都是公有的属性和方法；
    3.一看到A.prototype={}-->这是自己创建的原型对象，上面一定没有constructor,这个实例就不能进行类的细分；
    4.一看到__proto__：这是进行原型链的查找；

27.//批量添加A这个类的公有属性和方法；
      A.prototype={
          constructor:A,
          show1:function(){
              alert(123)
          },
          show2:function(){},
          show3:function(){},
      };

  注意：关于系统内置类不可以批量操作，这是系统内置类的自我保护机制；但是，可以一个一个操作；
28.为什么学习原型：
    1）可以知道系统内置类上的所有属性和方法；方便自己拓展学习
    2）可以给系统内置类上扩展一些公有的方法和属性；
29.关于链式操作
为什么能进行链式操作？因为每个方法调用后必须得有一个返回值，并且，这个返回值一定得是数组，才能继续通过点调用数组的其他方法；
30.call()  方法，他在Function.prototype这个公有空间中，所以，每个函数实例都可以call方法；
作用:call()中的第一个参数：用来改变this执行；
    call()中从第二个参数开始，每个参数用逗号隔开，都是用来给函数中一个个传参的；

31.关于对象属性的判断--返回值：boolean值
    1）in 用来判断这个属性是否是对象上的属性：公有属性和私有属性；
    2）hasOwnProperty() 用来判断是否为私有属性
    3）需求：如果判断是否为公有属性？hasPubproperty

32.obj.isPrototypeOf(obj2) 判断obj是否在obj2的原型链上；返回的也是boolean值；

33.var obj2=Object.create(obj) 作用：把obj作为obj2的原型；
obj2.__proto__=obj
function myCreate(obj){
    function Fn(){}; //构造函数
    Fn.prototype=obj;//构造函数的原型
    return new Fn;//构造函数的实例
}

34.画图需要关注几点：1）类--构造函数 2）原型 3）实例 原型链__proto__

35.回调函数需要关注的几点
    1.回调函数：把一个函数表达式作为参数传给另一个函数；就是回调函数callback
    2.回调函数被调用的次数 --根据自己的需要调用n次；
    3.回调函数传参 callback(参1，参2)--如果函数定义了形参，但是回调函数中没有传实参，拿到的是undefined;
                --1)有call的时候从第二个参数开始传2）没有call的时候直接传
    4.回调函数中this的修改；callback中的this，一般都是window,callback如果想改变this指向---用call(改变this指向，参1，参2.。。。)；
    5.回调函数中有返回值吗？--返回值根据不同的条件进行判断是否有有没有返回值
36.不管是forEach还是map中都可以通过input 这个参数配合index修改我们的原数组；

37.重写：子类通过__proto__一级级往上去修改父类的属性和方法；这就是子类对父类的重写；
既然子类可以重写父类，系统为了防止子类通过__proto__去更改系统内置的属性和方法，所以在IE浏览器下，禁止我们使用__proto__;

38.继承：子类可以继承父类原有的属性和方法，但是当子类添加私有属性和方法的时候，不对父类造成影响；
    1）原型链继承：把父类的私有+公有的属性和方法，都作为子类公有的属性；
      核心：不是把父类私有+公有的属性克隆一份一模一样的给子类的公有吧；他是通过__proto__建立和子类之间的原型链，当子类的实例需要使用父类的属性和方法的时候，可以通过__proto__一级级找上去使用；
    2）call继承：把父类私有的属性和方法给了子类私有的属性和方法；
    核心思想：相当于把父类私有的属性和方法克隆了一份一模一样的给子类的私有属性；
    3）冒充继承：把父类公有的+私有的属性都作为了子类私有的属性；
    4）混合继承1：call继承+原型链继承
    call继承：把父类私有的作为自己私有的；
    原型链继承：把父类私有+公有做为公有的；
    问题：父类私有的，在子类私有+公有两个地方都存在；
    5）混合继承2：call继承+拷贝继承
    call继承：把父类私有的作为自己私有的；
    拷贝继承：通过for in循环，把父类公有的属性和方法克隆了一份一模一样的给子类公有的；
    6）寄生式组合继承：
    call继承：把父类私有的作为自己私有的；
    Object.create()思想：
        1）创建一个空类；
        2）给空类的原型上添加了父类原型的地址；（相当于把父类原型上的公有属性和方法，给了空类原型上）
        3）子类的原型上添加空类的实例；（这样，子类就可以通过__proto__去找父类公有的属性和方法；但是不受父类私有属性的影响）

39.面向对象设计模式 （在第六周第三天）
 //面向对象：它是一种看待世界（编程）的方式（世界观）

 //所有方法（行为）和属性，它依赖一个主体的（上下文）。每一个方法和属性不再是孤立的了

 //行为的载体，某个对象就是这些行为的载体，被拖拽的div只是这个载体上的一个属性

 //方法论
 //一个类的实例，是管理一系列方法或属性的组织者。
 //多例模式和单例模式

 var DOM={};//基于对象的
 //提出对象的概念，然后根据对象这种数据类型的特点，完成的工作，叫基于对象的编程
 //对象这种数据类型的特点是：它是复合的数据承载体（就是说它可以承载很多的数据），这个数据载体就可以把世界描述的更完整更准确
 DOM.fn1=function(){};
 DOM.fn2=function(){};

 //以下面向对象的
 //面向对象其实是“生产对象的方式的升级”
 var a1=new Array;
 var a2=new Array;


 ///面向对象更多强调的是组织和管理的功能，只是实现一个逻辑，它毫无优势可言。
 //在使用面向对象的方式写代码之前，先确定几个原则：
 //一、this是谁（当前实例，承载所有的这个类上的方法和属性的那个载体）
 //二、要规划一个基本的类的结构（先要对这个类进行抽象，然后再封装成一个类）
 	//动作也可以是“数据”（function也是数据类型）

 //1.this都要指向当前类的实例(这个实例未必有变量名)。如果和这个原则冲突，则强制执行这个原则，让this指向当前类的实例。什么时候可能会冲突呢？和事件绑定的原则有时候就会冲突
 // 规划一个类的结构：需要构造函数，需要三个基本的方法：down,move,up
 /*var a=new Array;
 a.slice;
 ele.onclick=a.slice;
 //张三.二哥.小舅.三姑.请吃饭（）
 a.slice()
 new Array().slice();*/

 //构造函数：初始化的作用
 /*
 function  Drag(ele){//ele是指的被拖拽的元素
 	//this是整个拖拽行为的载体
 	//ele只是Drag类的实例上的一个属性
 	this.ele=ele;
 	this.abcd=ele;

 	this.x=null;
 	this.y=null;
 	this.mx=null;
 	this.my=null;

 	this.DOWN=processThis(this.down,this);
 	function processThis(fn,obj){
 		//返回一个新的方法，还是fn的功能，但当方法执行的时候fn的this被强制指向obj
 		return function(e){fn.call(obj,e);}
 	}

 	//上边processThis的执行相当于下边的代码
 	var that=this;
 	this.DOWN=function(e){that.down.call(that,e)};//把定义的函数里的this都要换成that才行
 	this.DOWN=function(e){this.down.call(that,e)};//在函数里写this是错的
 	//this.DOWN=this.down.bind(this);

 	on(this.ele,"mousedown",this.DOWN);

 }

 function Drag(ele){

 	on(this.ele,"mousedown",this.down);//事件的原则是down绑定给了ele，则down执行的时候，down里的this会指向ele。这和面向对象的this原则冲突了。所以下边的要强制改变

 	//原则是：让this.__proto__.down在运行的时候，功能不能变，但this无论如何也要指让这里的this：就是实例
 	this.DOWN=function (e){this.down.call(this,e)};//让Drag类实例的down指向Drag类的实例
 	var _this=this;
 	this.DOWN=function(){this;_this.down.call(_this,e)};//要理解DOWN里的this是谁，小写的down里的this又是谁，这是两码事

 	//基于以上的原则，所以才抽象出一个新的方法
 	function processThis(fn,obj){
 		//返回一个新的方法，还是fn的功能，但当方法执行的时候fn的this被强制指向obj
 		return function(e){fn.call(obj,e);}
 	}
 	on(this.ele,"mousedown",this.DOWN);
 	on(this.ele,"mousedown",_this.down);//这样的绑定和下边的绑定一样的，前边的this或_this是找到down方法地址的路径
 	on(this.ele,"mousedown",this.down);



 }

 var obj1=new Drag(div1);//当使用new关键字去创建一个实例的时候，浏览器做了那些事
 //1.创建一个这个类的实例（这会构造函数被当成一个类来对待的）
 //2.返回了这个实例
 //3.以这个实例为上下文运行构造函数，就是说这Drag方法还会被当成一个普通的函数来执行，只不过是这函数的上下文是这个类的实例了
 //4.这个实例上天生就会有__proto__属性，使这个实例自动具有（共享）这个类的原型上的所有的方法和属性



***********************************************
 第三大类   原型的深入（函数的三种角色，已经一下小知识方法）

1.每个类都是一个函数数据类型
    Fn instanceOf Function --》true
    instanceOf：判断这个实例是否属于这个类
    每个类都是Function这个类的实例;
    所有的实例都是对象数据类型；
    Function.prototype它是一个函数数据类型，它是一个匿名函数；但是他的功能跟普通的原型对象一模一样；
2.Object是所有实例的基类；
    每个实例，通过__proto__都能先找到距离自己最近的类；但是，所有的实例，都能通过__proto__最终找到Object这个基类；
3.所有的类都是函数数据类型
    Object这个基类也属于函数数据类型
    Function和Object他们两个之间的关系：
    Function是Object这个基类的爹；
    Object.prototype是Function.prototype的爹；
4.函数的三种角色：
    1）普通函数：形成一个私有作用域-形参赋值-预解释-JS代码执行环境-作用域的释放；
    2）类：实例，原型prototype，__proto__原型链，constructor：所属的类；私有属性和公有属性。。。；
    3）对象：当函数是一个对象的时候，他其实就跟普通的对象没有区别；
       函数的三种角色之间互相不干扰；
5.Function.prototype这个公有属性空间中有call,bind,apply;所有，call，bind，apply只能通过函数数据类型调用；
6.call和apply和bind都是改变this指向
  1）call和apply的区别
    首先他们都是通过第一个参数改变this指向的；
    call 从第二个参数开始，一个个的传参，传递给call前面的函数的形参（也是对形参从左到右一个个的赋值的）
    apply 从第二个参数开始，以一个数组的形式传参；传递给apply前面的函数的形参（也是对形参从左到右一个个的赋值的）
  2）call和apply的执行步骤
    1.把call点前面的函数中的this关键字变成call的第一个参数
    2.把call点前面的函数执行；
  3）bind
    bind和call在传参的时候是一样的；（改变this指向，参1，参2。。。）
    bind预解析机制：1.首先改变bind中的this关键字，同时把bind点前面的函数中的形参传值，然后返回一个修改过的函数；我们可以用变量去接受这个返回的函数；
                  2.在需要的时候，调用返回的这个函数；
7.eval:让字符串作为JS代码来执行；
8. 一般情况下，我们开发JS都用非严格模式；
    /*非严格模式*/
    fn.call()//this - window;
    fn.call(null)//this - window;
    fn.call(undefined) //this -window

    /*严格模式下 'use strict'，给call或apply第一个参数传谁this就是谁，不传就是undefined*/
    fn.call() //this - undefined;
    fn.call(null) //this -null;
    fn.call(undefined) //this-undefined
9.函数定义3阶段：
    1.开辟一个空间地址
    2.把函数体中的JS代码做为字符串存在这个空间中
    3.把空间地址赋值给函数名
    所以:函数在定义阶段不能执行，因为函数在定义阶段就是字符串；
    Function.prototype.call=function(){
        //1.把this这个实例中的this关键字(this字符串)替换成call的第一个参数obj；
        //2.把this所代表的实例执行；
        this();
    };
***************************************************
第四大类  正则


1.正则由两部分组成：元字符+修饰符
  元字符：代表特殊意义的元字符 和 代表次数的量词元字符：
    1）特殊含义的元字符
        \n 换行元字符（在控制台换行）
        \b 单词边界，开头结尾和空格 'w1       w2 w3'
        ^ 开头
        $ 结尾
        [abc] abc三个中的任何一个
        [^abc]  除了abc三个中的任何一个
        [a-z]  任意一个字母
        [^a-z] 除了字母以外的任意字符
         \d 数字     \w 字母数字下划线     \s 空格
         \D 非数字   \W 非字母数字下划线    \S 非空格
     2）代表次数的量词元字符
         * 0到多次
         + 1到多次
         ? 0次或1次
         {n} 代表n次
         {n,} 至少n次
         {n,m} n到m次
     3）修饰符
        g 全局的意思
        i 忽略大小写
        m 换行操作 多行操作
2.正则：规则 用来操作字符串（匹配和捕获）一系列规则
    匹配？ 看字符串是否符合我们制定的规则； reg.test()
    捕获？ 把符合我们规则的字符串取出来；reg.exec() str.match();      str.replace();
3.正则创建的两种方式
    1)字面量创建方式
    var reg=/\d+/
    2）实例创建方式
    var reg=new RegExp('\\d+')
4.字面量创建方式和实例创建方式的区别
    1)实例创建，特殊含义的字符需要转义，而字面量方式创建不需要
    2）实例创建，可以拼接变量，但字面量方式不可以拼接变量；
5.捕获 正则有两个特点：
    1）懒惰性 解决措施-加全局修饰符 g;
    2)贪婪性 解决措施:量词后面加上?
6.reg.exec() 用来捕获符合我们规则的字符串，每次只能捕获到一个；捕获的这一个是个数组；这也是正则的懒惰性；
exec如果捕获到内容的话，会返回一个数组
    数组总共包含三项：
    1）符合规则的字符串内容；
    2）该内容的索引；
    3）input：原始字符串；
    如果exec找不到符合规则的内容的话，返回的是null;
    为何exec如果不加全局g的时候，每次都捕获到第一项内容；因为 reg.lastIndex永远都是从0开始的；
7.match实现的核心原理就是用exec分次捕获得到的；
    match和exec的区别：
    1）match一次性可以捕获到所有符合规则的内容，放在一个新数组返回；
    exec每次只能捕获到一个符合规则的内容，并且以数组的形式返回，我们要的内容一般是数组第一项；
    2）match不能进行小分组的捕获
    exec可以进行小分组的捕获，他的小分组从索引1开始（从第二项开始）；如果没有分组，exec数组中有3项；
8.exec
    1)每次只能找到一项-数组
        这个数组在没有小分组的情况，拿到这个数组只有3项：
            1.我们匹配到的内容
            2.内容的索引
            3.原始字符串
        这个数组如果有小分组
            1.我们匹配到的内容（如何大正则的内容）
            2.从第二项开始，一直到ary.length-2之前都是小分组捕获出来的内容；
            3.倒数第二项 -索引
            4.最后一项：原始字符串；
    2）exec和match区别：
        1）exec存在小分组，但match没有
        2）match一次性可以匹配到所有的内容，并且都放在一个数组中
        exec只能一次次的捕获；
    exec和replace运用思想是一模一样的；
9.捕获：1）exec 2）match 3）replace
10.replace
    1）如果没有正则，replace只能一次次的去匹配和替换
    2）如果用了正则，就可以批量替换
    replace的第二个参数，可以是个函数，函数的执行次数跟匹配成功的次数有关；
11.封装：1）封装match 2）封装 日期格式化
12.[]的总结
    1）[]里面的特殊字符没有特殊含义，代表的都是他本身的意思： + - .
    2)[]中不会出现两位数 [18-98]  1 or 8-9 or 8
13.（）的总结
    1）提高优先级 /^(18|19)$/   /^(1[89])$/
    2）分组的作用
    3)(?:)只匹配不捕获；
14.？的总结
    1）量词 0或1
    2）解决正则的贪婪性的问题；量词+?
    3)(?:)只匹配不捕获；
    4）（[+-]）? +or_可有可无
15.去除首尾空格 reg=/(^ +)|( +$)/g;
  去除开头空格 reg=/(^ +)/;
  去除结尾空格 reg=/( +$)/;
16.reg.test 和 reg.exec在捕获的时候，都会影响reg.lastIndex;
17.
  RegExp.$1 代表正则的第一个小分组
  RegExp.$2 代表正则的第2个小分组
  。。。。。。代表不同的小分组；
  关于RegExp需要注意的几点
  1）RegExp.$1  不影响lastIndex
  所以我们加了全局g的时候，可以用lastIndex去取值
  2)RegExp.$ 最大只能到$9; 如果大于$9，就取不到值，我们拿到的就是undefined；
  3)在replace下，最好不要用RegExp.$，因为他不兼容；最好用replace第二个参数（callback）自带的参数机制；
***************************************************
第五大类 DOM

1）盒子模型
1.css盒子模型： 设定好的宽高+padding+border+margin
2.JS盒子模型：
用JS提供的属性和方法去获取元素的各种样式值；
3.JS提供的属性和方法
    client系列： clientWidth clientHeight clientLeft clientTop;
    offset系列：offsetWidth offsetHeight offsetLeft offsetTop offsetParent;
    scroll系列： scrollWidth scrollHeight  scrollLeft scrollTop;
4.JS提供的属性的详细解读
1)client系列
  构成：
    clientWidth/height:设定的宽（高）+左右padding（上下padding）;
    clientLeft/Top:border的宽度；
  是否受内容溢出的影响：不受溢出影响；
2）offset系列：
  构成：
    offsetWidth/height: 设定宽（高）+左右padding（上下padding）+border
                 clientWidth+border
  offsetLeft:当前元素的外边框距离定位父级的内边框的距离；
  是否受内容溢出的影响：不受溢出内容的影响；
  offsetLeft是从margin里边开始算的，但绝对定位是从margin外边开始起作用。这样offsetLeft的值赋值给style.left会导致margin的值被重新计算
3）scroll系列
   构成:
   scrollHeight:约等于上padding+真实内容的高度
   为什么是约等于：
   1）同一元素，不同浏览器测试的值不同；
   2）同一元素，是否溢出隐藏，在同一浏览器下也不相同；

（（（（（（（（（（（（（（（（
    内容的宽度和高度：我们设置的width/height这俩个演示就是内容宽度和高，如果没有设置高度height值，容器的高度会根据里面内容自己进行适应，这样获取的值就是真实内容的高；如果设置固定的高度了，不管内容是多了还是少了，，其实我们内容的高度指的都是设定的那个值
       真实内容的宽度和高度：这个代指的是实际内容的宽高（和我们设置的height没有必然的联系）。例如：我设置高度为200px，如果内容有溢出，那么真实的内容的高度就是办溢出的内容高度也要加进来
   1.client 系列（当前元素的几个私有属性）
       clientWidth/clientHeight：内容的宽度/高度+左右/上下填充
       clientLeft:左边框的宽度    clientTop:上边框的高度（border[left/Top/Width）
    2.offset系列
       offsetWidth/offsetHeight:clientWidth/clientHeight+左右/上下边框（和内容是否溢出也没有任何关系）
       offsetParent:当前元素的父级参照物
       offsetTop/offsetLeft：当前元素的外边框距离父级参照物的内边框的偏移量

       3.scroll系列
       scrollWidth/scrollHeight:和我们的clientWidth/clientHeight一模一样（前提是：容器中的内容没有溢出的情况下）
       如果容器中的内容有溢出，我们获取的结果是如下规则：
       scrollWidth：真实内容的宽度（包含溢出）+左填充
       scrollHeight：真实内容的高度（包含溢出）+上填充
       但是获取到的结果都是约等于的值，因为：同一个浏览器 ，我们是否设置overflow=‘hidden’对于最终的结果是有影响的；在不同的浏览器中我们获取到的结果也是不相同的
       scrollTop/scrollLeft  滚动条卷去的高度/宽度


       2.关于JS盒子模型属性取值的问题：
       我们通过这13个属性值获取的结果永远不给能出现小数，都是整数；浏览器获取结果的时候，会在原来真实结果的基础上进行四舍五入；

       3.关于操作浏览器本身的盒子模型信息
       clientWidth/clientHeight是当前浏览器可视窗口的（一批幕的宽度和高度）
       scrollWidth/scrollHeight是当前页面的真实宽度和高度（所有屏加起来的宽度和高度~但是是约等于的值
           我们不管哪些属性，也不管是什么浏览器，也不管是获取还是设置，想要都兼容，需要写俩套
           document.documentElement[attr]||document.body[attr];->必须document.documentElement在前
           例如：
       [获取]（有返回值）
           document.documentElement.clientWidth||document.body.clientWidth
       [设置也需要写俩套]（设置没有返回值）
           document.documentElement.scrollTop=0;
           document.body.scrollTop=0;）））））））））））））））））））））））

5.发现4个小问题：
    1）对浏览器盒子模型的兼容处理（获取和设置）win;
    2）关于clientWidth（height），offsetWidth等只能拿到四舍五入的整数，不能取到小数
    3）以上涉及到的每种属性只能拿到复合值，无法拿到单独的高或者宽或者其他样式：
    (通过style只能拿到行间样式，不能拿到非行间样式) getCss;
    4)关于offset，当前元素的外边框距离有定位父级的内边框之间的距离;但我们没法知道，在页面多层嵌套及定位的情况下，该元素距离body的距离；offset
6.浏览器兼容处理思想
    1）浏览器异常捕获兼容处理 try...catch
    缺陷：无论浏览器是否支持，都会走一遍try里的JS语句，性能相对来说差；
    2）属性判断
        1.attr in obj
        2.obj.attr
        3. type of obj.attr==='function'
    3)浏览器版本判断 navigator.userAgent:可以打印出浏览器的详细信息，是个字符串；
        1.reg.test(navigator.userAgent)
        2.navigator.userAgent.search(reg)!=-1;找见了；
        navigator.userAgent.search(reg)===-1;没找见；
7.伪类：给一个标签的前面或者后面添加一个虚拟标签，我们可以对虚拟标签进行各种样式和内容的设置；
  伪类清除浮动：
  ul:after{
              display: block;
              content: '';
              clear: both;
          }

8.定位父级和结构父级
  parentNode 按标签算的话，最大值为html标签； 不按标签算--最大值htmlDocument;
  offsetParent 如果没有定位的话，定位父级默认就指向body；
*********************************************************
第六类：其他

1.关于惰性思想：
  它是JS高级编程技巧之一，在一个不销毁的私有作用域中，定义一个变量，保存我们的判断浏览器的布尔值；
  以后在需要判断浏览器的时候，只需要使用这个变量即可；
2.滚动条样式
  scrollbar-face-color:#FEFAF1; (立体滚动条凸出部分的颜色)
  scrollbar-highlight-color:#FEFAF1; (滚动条空白部分的颜色)
  scrollbar-shadow-color:#FEFAF1; (立体滚动条阴影的颜色)
  scrollbar-arrow-color:#E6C3B9;(上下按钮上三角箭头的颜色)
  scrollbar-base-color:#FEFAF1; (滚动条的基本颜色)
  scrollbar-darkshadow-color:#E6C3B9; (立体滚动条强阴影的颜色)
  scrollbar-3dlight-color:#E6C3B9;(滚动条亮边的颜色)
  scrollbar-track-color:#FEFAF1;} (滚动条的背景颜色)
3.
JS中的框架(类库)、插件
->框架/类库 (大)
  jQuery 提供了很多很多的常用方法,提供我们项目开发使用  不局限于具体的项目和功能,都可以调取使用

->插件(小)
  把某一个具体的功能封装成一个组件,以后我们在需要实现这个功能的时候,我们只需要直接引入进来即可，例如：我们可以把轮播图封装起来，以后在想实现轮播图直接引入调用即可

4.断点快捷键
  F11，逐语句调试（是最详细的调试，会进入到某个方法的定义中去跟踪）
  F10：逐过程调试（不会进入到自定义函数里去跟踪代码）
  F8：逐断点调试（相当于IE中的F5）
  当代码运行的时候，会停在断点的位置。如果代码不执行，断点没有意义。
  断点停在那一行代码，表示即将执行这一行代码（但是还未执行）

****************************************************
    第七类：（1）DOM库封装
DOM库的封装
1）获取元素
1.getByClass：限定范围的通过class名去获取元素
    1.有两个参数： curEle,strClass; 返回值：ary
    2.首先判断高级浏览器，支持className--注意：把通过className取到的类数组转成数组
    3.处理低级浏览器的兼容性
        1.把字符串去除首尾空格，通过split切成数组 aryClass
        2.获取当前元素下的所有元素 --通配符*
        3.遍历每个元素，分别判断每个元素上是否有所有的aryClass名--假设法
        4.等所有的大循环结束，返回一个数组
2.hasClass：判断某个标签上是否有某个class名
    两个参数：元素 ，class名(只验证一个class名是否有)
    返回值：布尔值 test校验的结果就是布尔值
    1）首先把传进来的class名进行去除首尾空格
    2）写正则 new RegExp('\\b'+className+'\\b');
    3)reg.test(curEle.className)
3.addClass   '   box1    box2    box3    '
    功能：如果元素身上没有这个名才给添加
    两个参数：元素 className;
    没有返回值，因为我们只是设置
    1)首先把传进来的strClass进行去除首尾空格，并用split切成数组 aryClass
    2）遍历aryClass里的每一项，判断元素身上如果没有这个class名（hasClass），才会添加;
    注意：添加时，一定要加' '空格；
4.removeClass
    两个参数：元素 移出的className ‘str1 str2    str3     ’;
    没有返回值；
    1）aryClass
    2)遍历aryClass,看元素身上有aryClass中的每一项，如果有，就删掉(替换成空)；
5.getCss
6.setCss：给某个元素的某个属性添加某个值；
    只能设置行间样式
    三个参数：curEle,attr,value;
    没有返回值；
7.setGroupCss :给一个元素添加一组样式
    两个参数：curEle,options
    没有返回值；

8.css
    参数：curEle
    有返回值：分情况考虑
    当我们取值的时候，有返回值
    当设置的没有
    1）判断第二个参数(arguments[1])是字符串还是对象
    2）如果arguments[1]是个字符串
        1）arguments[2]存在 ！==‘undefined’ 单个设置
        2）arguments[2]不存在 获取
    3）如果arguments[1]是个对象：设置一组元素
9.win
10.offset
2)关于节点
1.getChildren;-》获取当前元素下的所有子元素
    思路：在高级浏览器下 children; 低级浏览器 兼容处理；
    参数1个：当前元素
    1）在高级浏览器下 children，还要获取的类数组转成数组
    2）兼容处理后，拿到的就是数组；
    3)返回值就是数组
2.prev 获取上一个哥哥元素节点
    1)高级浏览器 flag -》peviousElementSibling
    2)低级浏览器兼容处理；
        1.先获取上一个哥哥节点 ：元素节点，注释节点，document，文本节点
        2.while（是个节点 && 不是元素节点）{}
     参数1个：当前元素
     返回值1个：当前元素的哥哥元素（上一个元素）
3.prevAll:获取当前元素所有的哥哥元素节点
    参数1个：curEle
    返回值：数组
    思路：
    1）现获取上一个哥哥元素节点
    2）只要哥哥元素节点存在，就继续往上找其他的哥哥元素节点，找到一个，给数组中添加一个；
    不知道要找多少次，用while循环
4.next：获取当前元素的下一个弟弟元素节点
    参数1个：curEle
    返回值1个：下一个弟弟元素节点
    1）高级浏览器中flag判断，通过nextElementSibling
    2)低级浏览器处理 nextSibling(下一个弟弟节点：元素，文本，注释，document)
     while(nex && nex.nodeType !==1){}
5.nextAll:获取所有的弟弟元素节点
    参数1个：curEle
    返回值1个：数组
    1）现获取到一个弟弟元素节点
    2）当这个弟弟元素节点存在的时候，继续往下找其他弟弟元素节点，找到一个给数组插入一个，不知道要找多次
    while循环
6.sibling:获取当前元素的相邻元素：上一个哥哥元素节点+下一个弟弟元素节点
    参数1个：curEle；
    返回值：数组
    哥哥存在，就放进数组
    弟弟存在，就放进数组
7.siblings:获取当前元素的所有兄弟节点：所有的哥哥元素节点+所有的弟弟元素节点
    参数1个：curEle；
    返回值：数组
    思路：所有的哥哥元素节点+所有的弟弟元素节点---》数组拼接 concat
8.firstChild:当前元素下的第一个子元素
    参数1个：curEle；
    返回值：第一个子元素
    思路：
    1）可以拿到当前元素所有的子元素 数组
    2）数组的第一项；
9.lastChild
10.index：获取当前元素的索引
    思路：就是当前元素的哥哥的个数
11.appendChild
12.prependChild
    思路：
    1）首先判断父容器下第一个子元素是否存在，
    2）如果存在，就插入到第一个子元素前面；
    3）如果不存在，就插入到父容器的末尾；
13.insertBefore
14.insertAfter


    （2）运动库封装
1.1.封装运动库的思路
    1.写公式
    var zhufengEffect={
        Linear:function(t,b,c,d){
            return c*t/d+b;
        }
    }
    2.封装一个move方法
        1.准备linear公式中的参数值,并且填充完begin,change
        var begin ,change,duration,time
        2.填充begin,change
        通过for in target这个对象
    3.开启一个定时器
        1）累加时间--停止条件：累加的time>=duration
            当停止条件满足时：
                1）把物体直接设置到target上
                2）关闭定时器
                3）判断是否有回调函数，如果有就执行，同时改变this指向
                4）return； 阻断程序执行的作用；
        2）获取最新位置
        3）设置最新位置
    4.tween系列公式
            1.effect 如果是个数字
                1）把数字做为索引取到数组对应的字符串
                2）通过“-”拆分字符串
                3）当数组长度>=2?zhufengEffect[ary[0]][ary[1]]:zhufengEffect[ary[0]];
            2.effect 如果是个对象
            当数组长度>=2?zhufengEffect[effect[0]][effect[1]]:zhufengEffect[effect[0]];
            3.effect 如果是个函数
            callback=effect;
        1.准备linear公式中的参数值,并且填充完begin,change
        var begin ,change,duration,time
        2.填充begin,change
        通过for in target这个对象
        3.开启一个定时器
            1）累加时间--停止条件：累加的time>=duration
                当停止条件满足时：
                    1）把物体直接设置到target上
                    2）关闭定时器
                    3）判断是否有回调函数，如果有就执行，同时改变this指向
                    4）return； 阻断程序执行的作用；
            2）获取最新位置
            3）分别设置最新位置
1.2.写运动库的思路：
    1）传参：curEle,target,duration,effect,callback
    2)开始为zhufengEffect.Linear(t,b,c,d);里面的参数t,b,c,d做准备
    3）var begin={}; var change={}; var t=null;
    通过for in target来填充begin和change；
    4）当所有参数都准备好的时候，开启定时器
        3）添加各种各样的运动效果
            1）默认的运动效果 tmpEffect=zhufengEffect.Linear;
            2)判断
                1）当effect是数字，把数字做为索引（%的思想），取出数组中对应的字符串效果；
                2）当effect是对象['xxx','easeIn']=>zhufengEffect[xxx]["easeIn"]
                3)当effect是函数，说明用户相传的是回调函数，此时给callback=effect;
        1）累加时间 time
            停止条件：time>=duration
                1)满足停止条件时，让物体到目标值target；
                2)clearInterval();
                3)运动结束后，还想干什么事 ：callback && callback.call(curEle);
                4)return;
        2)遍历对象，分别获取最新位置（通过公式Linear）,分别设置最新位置；
****************************************************************************************************
第八类：jQuery（在20160714――第一次接触闲聊里有更详细的jQuery）
1.jquery中的取值赋值合体
例子：
    1.html
    2.css
    3.attr
2.JS元素如何变成jquery元素？ $(JS元素)
jquery元素如何变成JS元素？ $('p').get(0)/ $('p')[0]
3.关于表单序列化：
注意：如果是选择按钮：无论多选还是单选，都必须选中，才能给后台传送有用的数据；
4.$.each() 和 $().each()区别和联系
联系：
    两个都可以遍历jquery元素中每一项
区别：
    1）$().each()不能遍历原生对象；只针对jquery元素
    2）$.each()既支持jquery元素，也支持原生数组、原生对象、原生类数组
5.
$(function(){

})类似于JS中的window.onload
JS中的window.onload：等页面中的所有元素和图片都加载完成才开始加载JS；
jquery中的加载只加载DOM部分，不管图片是否加载完成，只要DOM部分完成，就开始加载JS；
很多公司，都是只加载完DOM部分，就开始执行JS代码了；
6.JS中存在DOM映射，当页面的HTML结构发生变化的时候，元素集合会自动发生变化；
但是在jquery中不存在DOM映射，只能等页面结构已经变化后，再获取元素集合；

（主要在第四周第五天的内容上，还在周老师的课件上的第四周）

7.
    1）->jQuery中的筛选
      1)children:"子集筛选" 在当前元素的所有的子元素中按照规则进行筛选
      2)find:"后代筛选" 在当前元素的所有子子孙孙级别的元素中,按照规则进行筛选
      3)filter:"同级筛选"
          console.log($("body").children("div"));
          console.log($("body").find("div"));
          console.log($("div").filter(".cc"));//->首先获取页面中所有标签名为DIV的元素,存储在jQuery的集合中,filter是在集合中在进行二次筛选：把拥有cc样式的获取到

    2）->attr/prop & removeAttr/removeProp
      attr一般用来操作自定义的属性
      prop一般用来操作内置的属性
          $("body").attr("trueImg");
          $("body").attr("trueImg", "xxx");
          $("body").attr({
              cc: 1,
              bb: 2
          });
          $("input").prop("checked");

    3）->动画
    animate
    show("slow") hide("fast") toggle(300)
    slide系列
    fade系列
    stop:结束当前正在运行的动画,从当前元素的位置开始执行下一个动画/finish:结束当前正在运行的动画,但是会让元素立马运动到第一个动画的目标位置,然后从目标位置执行下一个动画

    4）  ->操作样式
    css
    addClass、removeClass、toggleClass、hasClass
    width([val])、height
    innerWidth、innerHeight  & outerWidth、outerHeight
    offset
    position

    5）  ->动态操作DOM元素的方法
    before after
    insertBefore insertAfter  append/appendTo prepend/prependTo
    remove clone
    html val text

    6）  ->事件
    on off  $().on("click",function(){})

    click、keydown、keyup...  $().click(function(){})
    bind unbind trigger  $("a").bind("click",function(){})  $("a").trigger("click");
    one
    delegate  $(".box").delegate("click","a",function(){});
    -> $(".box").on("click",function(e){
         if(e.target.tagName==="A"){

         }
    });

    7）   ->jQuery的循环机制
    each

    8）   ->查找
    eq(索引)  get(索引)  $()[索引]  $().slice([start,end])
    prev prevAll next nextAll siblings index parent parents
8.
  ->选择器
  一、在外面使用的$和jQuery是相同的
  扩展:多库并存(我们先引入jQuery,此时$代表jQuery;后期我们产品需求可能还需要引入Zepto,此时$代表Zepto;那么现在$就冲突了;)
      //    var j = jQuery.noConflict();//->jQuery提供的这个方法是为了转让对于$的使用权,只要执行这个方法,以后的$就不在等于jQuery了；我们定义的变量j就是jQuery最新的缩写,用j代替之前$；
  二、什么是jQuery选择器?
       //$("规则") 通过传递对应规则的字符串,把需要的元素都获取到,这就是表面上选择器的理解
         通过源码其实需要传递两个参数值:selector选择器类型  context上下文(默认可以不传,不传的话默认的上下文就是document)
             //$("div") 获取整个文档中的所有DIV
             //$("div",document.getElementById("box")) 获取#box这个盒子下的所有的DIV
             //    console.log($("div"));//->0~5存储的是获取的DIV length:6 context:document selector:"div"
             //    console.log($("div", document.getElementById("box"))); //->0~2存储的是获取的DIV length:3 context:div#box selector:"div"  (目前context传递的是一个原生的JS对象)
             //    console.log($("div", $("#box")));  ////->0~2存储的是获取的DIV length:3 context:document selector:"#box div" (目前context传递的是一个jQuery对象)
             //    //->context这个值传递的格式不一样,最后的实现原理其实是不一样的:传递一个JS对象,是真正的把context改变,获取的时候在一个上下文中获取；传递的是一个jQ对象,并没有把context改变,而是把我们传递进来的selector改变了;

             //->jQuery本身是一个类,我们通过$()/jQuery()返回的结果其实都是在创建jQuery这个类的一个实例(jQuery对象) ->选择器就是在获取类的实例
             //jQuery中提供的方法一共分为两部分:定义在类的原型上的方法,把类本身当做一个普通对象,定已在对象上的方法
9.jQuery的选择器类型
(1)基本
       #id
       element
       .class
       *
       selector1,selector2,selectorN  $("div,.cc,#a")

       (2)层次选择器：
       ancestor descendant  $("#div1 a")  $("#div1").find("a")
       parent > child  $("#div1>a")  $("#div1").children("a")
       prev + next  $("#div1+a") 下一个弟弟A
       prev ~ nexts $("#div1~a") 所有弟弟中的A

       (3)基本过滤器选择器
       :first  二次筛选,在一个集合中在进行筛选 $("a:last")->先获取所有的A,然后在所有A中把最后一个获取到
       :last
       :not  $("a:not(.public)")->先获取所有的A,然后在所有A中把没有public这个样式类名的A得到
       :even
       :odd

       :eq  $("a:eq(1)")
       :gt  大于某个索引
       :lt  小于某个索引

       $("a:gt(0):eq(1)") 先获取所有的A,在把第二个及以后的获取到(索引大于0),在最新的结果中在把索引为1这个找到

       :header
       :animated

       (4)内容过滤器选择器
       :contains $("a:contains('珠峰')") 在所有的a中筛选出内容包含珠峰的a
       :empty
       :has
       :parent

       (5)可见性过滤器选择器
       :hidden
       :visible

       (6)属性过滤器选择器
       [attribute]   $("a[id]") 所有有ID属相的A
       [attribute=value]
       [attribute!=value]
       [attribute^=value]
       [attribute$=value]
       [attribute*=value]
       [attrSel1][attrSel2][attrSelN]

       (7)子元素过滤器选择器
       :nth-child    $("a:eq(0)")  $("a:nth-child(1)")
       :first-child
       :last-child
       :only-child

       (8)表单选择器
       :input   $("input:text")
       :text
       :password
       :radio
       :checkbox
       :submit
       :image
       :reset
       :button
       :file
       :hidden

       (9)表单过滤器选择器
       :enabled
       :disabled
       :checked
       :selected
************************************************************************************************
第九类  事件

1.事件
    事件分为两部分:
    1)行为本身:浏览器天生就赋予其的行为 onclick、onmouseover(onmouserenter)、onmouseout(onmouseleave)、onmousemove、onmousedown、onmouseup、onmousewheel(鼠标滚轮滚动行为)、onscroll(滚动条滚动行为)、onresize(window.onresize浏览器窗口的大小改变事件)、onload、onunload、onfocus(文本框获取焦点行为)、onblur(文本框失去焦点行为)、onkeydown、onkeyup(键盘的按下和抬起行为)...
    哪怕我没有给上述的行为绑定方法,事件也是存在的,当我们点击这个盒子的时候，同样会触发它的onclick行为,只是什么事情都没做而已

        鼠标事件: MouseEvent
        onclick onmouseover onmouseout onmouseenter onmouseleave onmousewheel
        系统事件: Event
        onload onscroll onresize...
        键盘事件 KeyboardEvent
        onkeydown onkeyup onkeypress
        表单事件：FocusEvent
        onfocus onblur....

   2)事件绑定:给元素的某一个行为绑定方法
        DOM0级事件:元素的私有属性
        e.g  oDiv.onclick = function () {
            };
       当我们触发oDiv的click行为的时候，会把绑定的这个函数执行，onclick这个行为定义在当前元素的私有属性上
            1.DOM0级事件能发生冒泡阶段
            2.DOM事件里，this指向的都是当前元素
        DOM2级事件：在当前元素所属eventTarget这个类的原型上；
        解决了一个问题：在同一个元素上，触发相同的行为（事件），执行不同的方法；
        e.g   oDiv.addEventListener("click", function () {
                   console.log("ok");
               }, false);
               //->addEventListener这个属性是定义在当前元素所属EventTarget这个类的原型上的
2.我们是把匿名函数定义的部分当做一个值赋值给oDiv的点击行为(函数表达式)
      当我们触发#div1的点击行为的时候,会执行对应绑定上的方法
      重要：不仅仅把绑定的方法执行了，而且浏览器还默认的给这个方法传递了一个参数值->MouseEvent:鼠标事件对象
          1)它是一个对象数据类型值,里面包含了很多的属性名和属性值,这些都是用来记录当前鼠标的相关信息的
          2)MouseEvent-->UIEvent-->Event-->Object
            /*div--HTMLDivElement-->HTMLElement-->Element-->Node--->EventTarget--Object
            document.addEventListener("DOMNodeInserted",function(){alert("insert");},false)*/
          3)MouseEvent记录的是页面中唯一一个鼠标每一次触发时候的相关信息,和到底是在哪个元素上触发的没有关系
3.e:事件对象：记录本次操作的相关信息（分为鼠标事件对象（MouseEvent），和键盘事件对象（KeyboardEvent））
  DOM0级事件获取事件对象的方式不一样（  1）2）3）4）5）  ）
   1） e:存储的是触发当前元素的事件或行为的详细信息   e:事件对象
    但是他不兼容IE6-8:window.event;
    兼容处理：e=e||window.event;

    type:事件类型   例： 存储的是当前鼠标触发的行为类型
    clientX/Y:到可视区左上角的坐标位置；
   2） pageX/Y:到首屏左上角的坐标位置；它不兼容IE6-8；可以做如下兼容处理：
    e.pageX=(document.documentElement.scrollLeft||document.body.scrollLeft)+ e.clientX;
    e.pageY=(document.documentElement.scrollTop||document.body.scrollTop)+ e.clientY;

    e.keyCode:键盘的键码：当前键盘上每一个键对应的值
       //空格键(space)->32
       //回退键(Backspace)->8
       //回车键(Enter)->13
       //删除键(Del)->46
       //四个方向键->左 37 上38 右39 下40
       //
       console.log(e.keyCode);
   3） e.target:现在触发事件的这个元素--（事件源） 不兼容IE6-8：e.srcElement;
    兼容处理：e.target||e.srcElement;
    例：事件源,当前鼠标触发的是哪个元素,那么它存储的就是哪个元素，但是在IE6~8中不存在这个属性(e.target的值是undefined),我们使用e.srcElement来获取事件源
    4）阻止默认事件的兼容处理：
第一种兼容处理：e.preventDefault? e.preventDefault(): e.returnValue=false;
第二种兼容处理：return false;
    5)阻止事件传播（阻止冒泡的兼容处理）：
e.stopPropagation?e.stopPropagation():e.cancelBubble=true;

4.事件流：事件的默认传播机制:捕获阶段-> 目标阶段（事件源）-> 冒泡阶段
     想控制当前事件在事件流的哪个阶段发生：应该用DOM2级事件；（addEventListener第三个参数来控制）
     addEventListener->第一个参数是行为的类型 第二个参数是给当前的行为绑定的方法 第三个参数是控制在哪个阶段发生:true 在捕获阶段发生  false 在冒泡阶段发生

    捕获：从外向里依次查找元素；
    冒泡：从里向外触发元素身上的事件;当元素身上的事件click被触发的时候，如果他的父级身上有相同的事件，都会被触发；如果有绑定的方法，这些方法都会被执行；
5.onmouseenter和onmouseover都是鼠标滑上去的行为，但是onmouseenter浏览器默认阻止了它的冒泡传播(mark的onmouseenter行为触发，不会传播到box)；而onmouseover是存在冒泡传播的，想要阻止的话只能自己写代码阻止；
   一般onmouseenter搭配 onmouseleave来用
6.事件委托：利用了事件的冒泡传播机制，当很多元素触发了很多事件的时候，只给给事件源绑定事件
7.事件包括DOM0级事件和DOM2级事件
  DOM2级事件在元素所属的eventTarget这个类的原型上；
8.DOM2级事件的优点：
  1）可以在同一个元素，触发元素的同一个行为，执行不同的方法；（多次绑定）
  2）在DOM0级事件没有的属性，在DOM2级事件上会有；DOMContentLoaded:DOM结构的内容都加载完成
9.
  $(function(){})
  $(document).ready(function(){}) ---JS中的事件是DOMContentLoaded
  以上两个都是当DOM结构或者HTML页面加载完成的时候，在执行其他代码
  window.onload 当页面所有的元素（HTML页面结构，图片加载，音频，视频等）都加载完成
  jquery中可以多次调用$(function(){})，说明他用了DOM2级事件绑定
  jquery中加载完DOM结构才执行代码，说明他用了DOMContentLoaded这个事件；
10.在IE下，DOM0级事件和DOM2级事件（attachEvent）的联系和区别：
  1)在触发行为时，事件都带on
  2）DOM2级事件（attachEvent）,可以在同一个元素上，触发同一个行为，绑定多个方法；
11.DOM2级事件： addEventListener   attachEvent
12.DOM2级的事件机制--标准浏览器下的反映
  1)在同一个元素同一个行为上，绑定多次相同的方法；浏览器默认只会保留一个
  2）DOM2级事件中绑定的方法中的this，就是当前触发事件的这个元素；
  3）按照绑定的先后循序，执行该元素同一个行为上绑定的方法；
  .......................
  在非标准浏览器下需要解决的兼容问题：
  1）重复问题：如果有了，不添加；
  2）this问题：call
  3）顺序问题：
13.浏览器事件池
14.关于解决this问题：
  在绑定事件的时候，把绑定的方法都放在一个匿名函数中，在匿名函数中通过call去改变this指向；
  绑定多次，就会有多个匿名函数，我们把每个匿名函数都放在自定义属性curEle['myBind'+eventType]这个数组中；如果数组中已经有这个行为对应的方法，不做任何操作，直接return；
  在解除事件绑定的时候，我们不知道应该解除数组中的哪个匿名函数；所以，在给数组中存储匿名函数之前，我们给匿名函数起个名字；
  在解除事件绑定的时候，可以遍历数组中的每一项，通过判断数组中哪一项的name===eventFn;如果等于就解除一这项；同时，要删除自定义事件池的中的这个方法；为了防止数组塌陷引发的解除事件绑定的错误问题，提前保存cur=ary[i];

15.
  1)首先处理浏览器的兼容性：
      在标准浏览器下，addEventListener
      在非标准浏览器下,attachEvent
  2)this问题：
      不能直接在addEventListener(curEle,eventType,eventFn.call(curEle));
      为了改变this指向，我们只能在匿名函数中去改变this;
      如果直接在元素的自定义属性上定义一个属性名，专门用来存储每个匿名函数；这样会存在覆盖问题；
      所以，我们只能在自定义属性上去创建一个数组，数组中存的就是每个包裹方法的匿名函数；为了区分数组中每个匿名函数都是谁，所以给每个匿名函数都起了名字；这样，我们在解除事件绑定时候，可以根据名字解除对应的匿名函数；

15（1）     鼠标抬起的时候，释放焦点     oDiv.releaseCapture&&oDiv.releaseCapture()
           鼠标按下的时候，聚集焦点      oDiv.setCapture && oDiv.setCapture();//这是mousemove事件的专有方法，专门用来处理当mousemove事件连续触发时，元素会丢失鼠标的问题的。元素会掉丢鼠标，是由于浏览器的性能问题造成的。this.setCapture是IE专用的方法

16.  关于所有DOM2级库方法的总结：
  * 1）bind里做了什么事？--解决了 this问题，重复问题
  *   1.处理标准浏览器和低级浏览器的兼容处理
  *   2.处理this问题：把每个匿名函数（给绑定的方法改变this指向）放在定义属性这个数组中；这就是自己的事件池; 把每个匿名函数也放在系统事件池中；
  *   3.为了在unbind中能够解除浏览器事件池中的匿名函数；需要在bind中给自己的事件池添加以前，给每个匿名函数起个名字 tmpFn.name=eventFn;
  * 2)unbind
  *   1.拿到自定义属性上的数组；
  *   2.判断数组中谁的名字===eventFn;浏览器事件池解除这个匿名函数；删除数组中的这一项匿名函数；
  * 1）on里想干什么事？--绑定事件 this问题， 重复问题 ，顺序问题；
  *   1.创建一个自定义属性，做为数组，存的是每个行为绑定的方法；--做为自己的事件池
  *   2.给元素的某个行为绑定bind一个run方法（直接把run方法放到系统事件池里了）
  *   bind(curEle,eventType,run)//run方法中有一个系统传入的参数e：事件对象；run方法中的this就是curEle;
  * 2）run方法里干了什么事？
  *   1.核心：把元素自定义属性上的数组中的所有方法都执行了； this？事件对象？
  *   2.做了低级浏览器的兼容处理；if(!e.target).....
  * 3）off里干了什么事？--解除绑定
  * 系统的事件池里，只有一个 run方法，如果想解除事件绑定，只要删除数组中原有的方法，run方法中就不会执行已删除的这个方法；
***********************************************************************************************
第十类   柯理化函数

1.柯理化函数思想:利用作用域不销毁的原理把一些后期需要使用的东西预先存储起来,后期直接拿来使用,在bind中,我们是预先把需要执行的函数和改变的this都存储起来了,后期执行的时候在改变，也可以理解为事先就把函数中的this都指定好了,这种JS的预存储或者预处理机制就是柯理化函数思想...



*******************************************************************************************
第十一类   移动端

1.
在 <title></title>前加上
<!-- 这句话是移动端必备的  meta:vp+tab快捷键-->
      <meta name="viewport"
            content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"/>

2. e.changedTouches    触点集合
          this.mx=e.changedTouches[0].pageX;//第0个手指，当前触点的x轴的坐标(把第一个触点的x轴坐标保存到自定义属性x上)


*****************************************************************************************************
终极类：几个步骤
1.封装方法的思路
    1.功能：一定要明白这个方法干什么用？
    把类数组转成数组
    2.考虑是否有参数：类数组；
    3.考虑是否有返回值：数组；
    4.写核心程序
    判断浏览器是否兼容：
    思路1：属性的判断：xx.xxx; '属性名' in 对象
    思路2：try...catch...
2.功能：把JSON格式的字符串转成JSON格式的数据（对象）
    2.考虑是否有参数：字符串
    3.考虑是否有返回值：对象
    4.判断浏览器是否兼容：思路1：属性的判断：xx.xxx; '属性名' in 对象

    JSON，他是一种数据格式；用来进行前后台数据交互；
        1.JSON是window上的一个对象，里面包含两个方法

         1.JSON.parse(jsonStr);jsonStr:json格式的字符串 功能：把JSON格式的字符串转成JSON格式的数据；
        2.JSON.stringify(jsonObj) 把JSON格式的数据转成JSON格式的字符串；
3.写JS的顺序
    1）HTML+css一定先写好（用的假数据）
    2）写JS：不是写代码，而是写思路
    3）写代码；
4.从页面中拿过来的所有内容都是字符串；
5.浏览器异常捕获
    try{//执行是浏览器支持并且能正常执行的JS语句
        console.log(a)
    }catch(e){
        //当try里面的语句不能正常执行的时候，走的是catch里面的语句；
        console.log(e)//打印出错误原因
    }finally{//finally里面的语句，是无论try能否正常执行，都会走finally；所以，finally基本不用；
        console.log(111)
6.三种绑定数据的思路及DOM回流
    DOM回流：当页面中的HTML发生变化的时候，会对页面中的所有内容都重新渲染；
    思路1：字符串拼接
        缺点：相当于把页面中的内容拿出来，跟我们已经拼接好的字符串str再进行字符串拼接；最后拿到新拼接好的字符串把他转化为标签，重新放入页面中；所以，以前页面中元素身上的事件就都没有了；
        优点：只引发一次DOM回流
        工作中用的最多的就是字符串拼接；
    思路2：动态创建，循环中每次插入---缺点：每循环一次，就会DOM回流一次，耗性能；
        优点：可以保留以前元素身上的事件
    思路3：动态创建+文档碎片document.createDocumentFragment();
        他只引发一次DOM回流，而且可以保留原来元素身上的事件；
7.数据和页面绑定思路：
          1.文档碎片
          2.字符串拼接
          3.for循环每次都插入，比较耗性能；
8.DOM映射：1.HTML页面结构中的标签（HTML）  2.获取到的元素集合（js）
      1）当页面中的HTML标签发生变化的时候，我们不需要重新获取，JS中的元素集合就会对应的发生变化；
      2）当我们用JS操作页面中的内容的时候，页面中的标签也会相应的发生变化；
      他们两个互相影响；
9.隔行换色实现思路：
          1.switch
          2.for循环+一句话%;
          3.if..else if....

10.数字排序 ary.sort(function(a,b){return a-b}) 从小到大
               ary.sort(function(a,b){return (a-b)*-1})
   汉字排序 'a'.localCompare('b')
11.想实现排序需要3步骤：
    1.类数组转数组；
    2.数组排序sort
    3.把排序好的数组内容，重新插入页面
12.JS的异步编程：同步和异步
   1） false同步：当前项目干不完，不会开始下一项
    true异步：当前项目干不完，不等他，继续执行后面的项目，等后面的项目都执行完成时候，再返回来执行当前项目；
    2）同步：当前的任务没有完成，不会开始下个任务
        在JS中用的最多的是同步；最典型就是（for，while） 循环
    异步：当前任务没有完成，不会等，继续开始执行下个任务，等下面所有的任务都完成时候，在回过头来执行当前这个任务的结果；如果下面任务永远都完成不了呢？不会回头执行前面的结果；
   3） JS中常见的异步处理：
    1）元素身上的事件
    2)定时器
    3）回调函数
    4）ajax
13.解析ajax4步骤
    1.创建一个ajax对象
    2.打开一个地址，3个参数（'get','data.txt',false）
    3.响应请求 xml.readyState xml.status
    4.发送请求 xml.send();
14.需求：隔行换色的表格排序
   1）获取并解析数据 getDate()
   2)绑定数据 bind() 用了两种思路：1）字符串拼接 2）动态创建
   3）隔行换色 changeColor 两种思路1）switch 2）直接用% 循环中套一句话
   4)表格排序: 1.类数组转数组 2.sort排序 3.重新插入页面
   优化处理： this ， 传索引n , flag -1, 让当前点击列 flag*=-1;其他列 =-1；
15.关于表格排序的思路总结
     1）总思路
     1.获取并解析数据--ajax
     2.绑定数据
          用了两种思路：
          1.字符串拼接
          2.动态创建和文档碎片
     3.隔行换色
          1.switch
          2.if...elseif...else...
          3.for循环+一句话%的思想
          %的小技巧：有几种情况就%几；
     4.表格排序
          关于循环绑定事件2种思路：
          1.自定义属性
          2.闭包
     5.优化处理
          1.this的处理：
              1.当触发元素身上事件的时候，会执行一个函数，函数中的this指向当前这个元素
              2.call
              3.回调函数中this的处理---在回调函数外面保存_this=this变量；
          2.自定义属性存内容
              对象.flag=-1;
              没发生点击事件的时候，都*=-1;
              注意点：点击哪一列的时候，让哪一列*=-1；其他没发生点击事件的列都恢复初始状态-1；
16.跑马灯的思路：
    实现核心原理：不断改变ul的left;
    1.为了防止空白，给ul内容多克隆了一份
    2.为了让所有的li在一行显示，重新设置ul的宽度 一个li的宽度*li的个数
    3.不断减少ul的left，当ul的left<=-800时；让left=0;
    4.鼠标移入停止运动，移出继续运动
17.定时器小技巧
   1）开启定时器前，可以先关闭定时器
   2）定时器的时间设置越小越不精准，而且，即使设置为0；他也不是0ms，因为各大浏览器对定时器，都有一个最小值的设置；
   7.单张图片的延迟加载
   需求：当整张图片都进入我们眼睛可视区的时候，才让他加载，否则，不加载；
   1）一开始时，就不能把正确的地址放在src上，把真正的地址存在realImg这个自定义属性上
   2)当图片满足条件的时候，才把真正的地址从realImg上取下来，验证图片地址无误的时候，才放在src上
       1）把真正的地址从realImg上取下来
       2）创建一个对象，来校验图片地址是否正确
       3）对图片地址的校验结果做不同的处理；
       图片地址正确：赋值给src
           1)把正确的图片地址赋值给src
           2）释放掉不用的对象 tmpImg;
           3)避免重复加载；
       图片地址错误：自动报错，我们需要做的无论成功与否，都避免重复加载；
   公式：图片距离body定位的位置+图片的高度<浏览器卷去的高度+可视区的高度；
18.回到顶部思路总结：
    1）当点击按钮的时候，让滚动条匀速的回到顶部
    2）如何匀速？--公式的计算
    总距离 target --utils.win('scrollTop')
    总时间 duration --1000ms
    频率 interval --10ms
    求 步长 step=target/duration*interval
    3）开启一个定时器，每次获取最新的浏览器卷去的高度-step；然后重新赋值；
    注意点：什么时候关闭定时器？ 最新的浏览器卷去的高度=0；
    4）当浏览器卷去的高度>可视区的高度时，让按钮显示，否则，按钮隐藏
    5）当点击按钮的时候，让按钮立即消失；
19.回到顶部--当划动鼠标滚轮时，立即停止运动
    1）在全局建立变量布尔值 var bOk=false;
    2)在setInterval里添加bOk=false;
    3)在window.onscroll里添加
    if(bOk){
        clearInterval(timer)
    }
    bOk=true;
    注意：如果想实现“划动鼠标滚轮时，立即停止运动”；一定不能写之前点击按钮，让window.onscroll=null;因为这样滚动事件就被干掉；
20.瀑布流
    1）封装一个rnd
    2）封装创建一个元素li,高度随机，背景色随机；然后返回这个li元素
    3）通过循环创建50个元素；每个元素分别插入最短的ul（类数组转数组，排序）里，每次往ary[0]里插入li;
    4)划动滚轮，满足一定条件时，插入50个元素
    条件 scrollBottom>document.body.scrollHeight-500

21.固定步长的运动
    1)设置目标值和固定步长
    2）开启定时器，获取当前最新位置；在最新位置上+=step；
    3）停止条件：当最新位置+step>=target时，停止运动
    问题：不加边界值，出现反弹或滚动条
    解决办法：边界值判断
22.计算步长的运动
    1）target/duration*interval
    2）开启定时器，获取当前最新位置；在最新位置上+=step；
    3）停止条件：当最新位置+step>=target时，停止运动
    问题：不加边界值，出现反弹或滚动条
    解决办法：边界值判断
23.匀速运动：利用Linear(t,b,c,d);
    t:time
    b:begin
    c:change
    d:duration
    1)开启一个定时器，不断累加时间
    2）通过Linear公式计算当前的位置，并且重新设置新位置
    3）停止条件：当time>=duration时，把物体设置到目标值，同时停止运动
24.物体的多运动（至少写5遍以上，要求自己靠自己思路可以写出来）
    1）两个begin，两个target,两个change，1个duration，time；
    2）写出以上值是为了给Linear传参，通过公式和定时器计算最新的位置并且重新设置新位置
    3）停止条件：当time>=duration时，把物体设置到目标值，同时停止运动
25.用setTimeout实现点击左右运动：
    1）向左走向右走，取决于当前位置与目标值的大小判断
    2）如果当前位置<目标值; 当前位置+=step;反之，当前位置-=step;
    3)停止条件都是 当前位置（+/-）step>=(<=)target;直接设置物体到目标值；
    4）通过setTimeout让move方法不断的调用
    5）但以上调用 move需要传参，存在性能问题：
    在匿名函数中，如果有函数调用并且需要参数，而参数需要把匿名函数当作跳板去取参数值，这就会导致匿名函数里的东西被外面占用；形成无数个不销毁的私有作用域；
    而_move避免了匿名函数不销毁的问题；

26.关于运动的小技巧：
1）不加边界值，出现反弹或滚动条--解决办法 边界值判断
2）开启一个定时器前，先关闭定时器
3）保存定时器的全局变量，可以写在自定义属性上，避免全局变量冲突的问题和性能问题；
4）在匿名函数中，如果有函数调用并且需要参数，而参数需要把匿名函数当作跳板去取参数值，这就会导致匿名函数里的东西被外面占用；形成无数个不销毁的私有作用域；
而_move避免了匿名函数不销毁的问题；

27.基础版左右切换的轮播图--分析
   一 1）图片自动轮播 :定时器+autoMove
    2）焦点按钮自动轮播：在哪里调用已经封装好的bannerTip;
    3）鼠标移入停止运动，鼠标移出继续运动
    移入：显示左右按钮
    移出：隐藏左右按钮
    4）点击焦点手动切换:handleChange---通过索引改变step;别忘记通过step改变图片运动和焦点运动
    5）点击左右按钮手动切换
        1）点击向右的按钮=autoMove
        2)点击向左的按钮：step--;同时判断step为<=0的情况
   二 关于引入JS的顺序
    1）utils.js
    2)move.js:因为move要用到utils里面的内容
    3）banner.js：因为banner要用到以上两者中的内容

28.关于普通函数改成构造函数的思路
    1）把全局变量都变成私有属性--私有属性都在构造函数里
    2）把全局函数都变成公有方法--prototype上
    3）如果给prototype={}，注意constructor指向
    4）init：初始化函数；这里面放的就是函数调用的思路
        //1.getData
        //2.bind
        //3.lazyImg
        //4.
        clearInterval(autoTimer);
        autoTimer=setInterval(autoMove,interval);
        //5.bannerTip;
        //6.移入移出 overOut
        //7.handleChange
        //8.leftRight左右按钮切换
    5)改this；
29.左右切换的轮播图思路--完整版
    1）获取并解析数据，4步骤
    2）绑定数据 --字符串拼接来绑定
    3）图片延迟加载--2）这步拼接的图片，应该realImg来存放图片真正的地址；
                   遍历所有的图片元素；分别创建img对象，用他来测试我们的图片地址是否正确；
                   当onload加载成功的时候，才把正确的地址赋值给图片的src;
       注意问题：onload是异步，所以外面循环中的i值，在onload里一定出错；
       解决方式：思路1）自定义属性
                思路2）闭包
    4）自动播放轮播图 开启一个定时器,建立一个公有的step,现在可以用step来控制图片的轮播，以后，可以用step来建立 图片和按钮之间的联系；
    5）焦点自动轮播； 注意：焦点封装的函数在哪里调用？在autoMove里面调用，因为autoMove中step发生了改变
    6）鼠标移入移出：移入停止运动，移出继续运动
                   移入显示左右按钮，移出隐藏左右按钮
    7）焦点图手动切换，核心思想：点击每个按钮的时候，把这个按钮的索引做为step，用过step去运动改变left； zhufengEffect(...);别忘了把焦点也改变 bannerTip();
    8)点击左右按钮切换轮播图
        点击右按钮=autoMove;
        点击左按钮，让step不断--;
            注意：当step<=0的时候，让step=aLi.length;让oBoxInner迅速到达索引为4的那一张；（实际就是跟第一张长得一模一样的第5张）；
            step--;//真正的最后一张，不是跟第一张一样的；
            zhufengAnimate()
****************************************************************************************************


快捷键  /**+回车  --->/**                -->前提是下面的方法写完
                  *
                  * @param curEle
                  * @param eventType
                  * @param eventFn
                  */




















